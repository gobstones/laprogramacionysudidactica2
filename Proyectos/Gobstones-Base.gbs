/*@ATTRIBUTE@block_name@Poner _, _ veces@*/ procedure Poner__Veces(c,n) { return(AuxPoner__Veces(c,n)) }
/*@ATTRIBUTE@block_name@Sacar _, _ veces@*/ procedure Sacar__Veces(c,n) { return(AuxSacar__Veces(c,n)) }
procedure SacarTodas()   { AuxSacarTodas() }
procedere SacarTodas_(c) { AuxSacarTodas_(c) }

//--------------------------------
// Operaciones auxliares de Gobstones
//--------------------------------
procedure AuxPoner__Veces(c,n) { repeat (n) { Poner(c) } }
procedure AuxSacar__Veces(c,n) { repeat (n) { Sacar(c) } }

procedure AuxSacarTodas()   { foreach c in [Azul..Rojo] { AuxSacarTodas_(c) } }
procedure AuxSacarTodas_(c) { AuxSacar__Veces(c, nroBolitas(c)) }

function aux_colorParaElDato()    { return(Negro) }
function aux_colorParaElTipo()    { return(Azul)  }
function aux_colorParaElReverso() { return(Rojo)  }
function aux_colorParaMarca()     { return(Verde) }

//--------------------------------
// Operaciones de movimiento
//--------------------------------
procedure AuxPasarASiguientePosiciónHacia(dir) { if (puedeMover(dir)) { Mover(dir) } }
procedure AuxPasarASiguientePosición() {
    if     (puedeMover(Este))  { Mover(Este)                     }
    elseif (puedeMover(Norte)) { IrAlBorde(Oeste) Mover(Norte)   }
    else                       { IrAlBorde(Oeste) IrAlBorde(Sur) }
}

//--------------------------------
// Operaciones de recorrido
//--------------------------------
// La marca son 100 bolitas del aux_colorParaMarca, pero puede haber otras marcas antes
function aux_hayMarca()  { return (nroBolitas(aux_colorParaMarca())>100) }
procedure AuxMarcar()    { AuxPoner__Veces(aux_colorParaMarca(),100) }
procedure AuxDesmarcar() { 
  // PRECONDICIÓN: hay una marca en el lugar (o sea, aux_hayMarca() es verdadero)
  AuxSacar__Veces(aux_colorParaMarca(),100) 
}

function aux_terminoElRecorrido() { return (not puedeMover(Este) && not puedeMover(Norte)) }

procedure AuxVolverALaMarca() {
  // PRECONDICIÓN: hay una marca en el tablero
  IrAlBorde(Sur) IrAlBorde(Oeste)
  while (not aux_terminoElRecorrido() && not aux_hayMarca()) { AuxPasarASiguientePosición() }
}
