/*==================================================================================================*/
/*---- PROVEE ---------------------------------------------------------------------------------------/
/*---------------------------- INTERFAZ de 03-CartasEspañolas-Base.gbs ------------------------------/
/*---------------------------------- (ver  19 líneas más adelante) ---------------------------------*/
/*------------------------- INTERFAZ de 03-01-PalosDeCartaEspañola-Base.gbs -------------------------/
/*---------------------------------- (ver 582 líneas más adelante) ---------------------------------*/
/*------------------------ INTERFAZ de 03-02-ValoresDeCartaEspañola-Base.gbs ------------------------/
/*---------------------------------- (ver 419 líneas más adelante) ---------------------------------*/
/*--------------------------------- INTERFAZ de 01-Letras-Base.gbs ----------------------------------/
/*---------------------------------- (ver 827 líneas más adelante) ---------------------------------*/
/*------------------------------- INTERFAZ de 00.Gobstones-Base.gbs ---------------------------------/
/*---------------------------------- (ver 733 líneas más adelante) ---------------------------------*/
/*==================================================================================================*/

/*==================================================================================================*/
/*--------------------------------- REQUIERE 00-Gobstones-Base.gbs ---------------------------------*/
/*--------------------- (provisto también para 03-01-PalosDeCartaEspañola-Base.gbs) ----------------*/
/*-------------------------- (y para 03-02-ValoresDeCartaEspañola-Base.gbs) ------------------------*/
/*-------------------------- REQUIERE 03-01-PalosDeCartaEspañola-Base.gbs --------------------------*/
/*------------------------- REQUIERE 03-02-ValoresDeCartaEspañola-Base.gbs -------------------------*/
/*==================================================================================================*/

/*==================================================================================================*/
/*---------------------------- INTERFAZ de 03-CartasEspañolas-Base.gbs ------------------------------/
/----- Autor: Pablo E. "Fidel" Martínez López -------------------------------------------------------/
/----- EMail: fidel@unq.edu.ar                -------------------------------------------------------/
/----- Fecha creación: 2018.06                -------------------------------------------------------/
/----- Fecha última modificación: 2018.06     -------------------------------------------------------/
/----- Licencia: GNU General Public License, v2                                             ---------/
/----- Sitio Oficial de la licencia: http://www.gnu.org/licenses/old-licenses/gpl-2.0.html  --------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*-------------------------------------- Definiciones de tipos --------------------------------------/
/---------------------------------------------------------------------------------------------------*/
type CartaEspañola is variant { 
                                case Carta   { 
                                  field valor 
                                  field palo 
                                }
                                case Comodín {}
                              }

//---------------------------------------------------------------------------------------------------/
/*--------------------- Operaciones de creación de cartas españolas (interfaz) ----------------------/
/---------------------------------------------------------------------------------------------------*/
/*@ATTRIBUTE@block_name@carta _ de _@*/           function dameCarta__(v,p) { return(aux_armarCartaEspañola(v, p)) }
/*@ATTRIBUTE@block_name@comodín@*/                function dameComodín()    { return(aux_armarComodín())           }

//---------------------------------------------------------------------------------------------------/
/*---------------------- Operaciones de acceso de cartas españolas (interfaz) -----------------------/
/---------------------------------------------------------------------------------------------------*/
/*@ATTRIBUTE@block_name@es comodín _@*/           function esComodín_(c)          { return(aux_esComodín(c))   }
/*@ATTRIBUTE@block_name@palo de la _@*/           function dameElPalo_(c)         { return(aux_dameElPalo(c))  }
/*@ATTRIBUTE@block_name@número de la _@*/         function dameElValor_(c)        { return(aux_dameElValor(c)) }

/*@ATTRIBUTE@block_name@_ es menor carta que _@*/ function esMenorCarta__(carta1, carta2) { return(aux_esMenorCartaEspañola(carta1, carta2)) }
/*@ATTRIBUTE@block_name@_ es mayor carta que _@*/ function esMayorCarta__(carta1, carta2) { return(aux_esMayorCartaEspañola(carta1, carta2)) }
/*@ATTRIBUTE@block_name@el palo más chico@*/      function minCarta()             { return(aux_minCartaEspañola()) }
/*@ATTRIBUTE@block_name@el palo más grande@*/     function maxCarta()             { return(aux_maxCartaEspañola()) }
/*@ATTRIBUTE@block_name@carta siguiente a _@*/    function cartaSiguiente_(carta) { return(aux_cartaEspañolaSiguiente(carta)) }
/*@ATTRIBUTE@block_name@carta previa a _@*/       function cartaPrevia_(carta)    { return(aux_cartaEspañolaPrevia(carta)) }

//---------------------------------------------------------------------------------------------------/
/*---------------- Operaciones de sensado de cartas españolas en el tablero (interfaz) --------------/
/---------------------------------------------------------------------------------------------------*/
function hayCarta() { return(aux_hayCartaEspañola()) }

function laCartaEstáTapada() { return(aux_laCartaEspañolaEstáTapadaConBoom())                    }
function hayCartaTapada()    { return(aux_hayCartaEspañola() && aux_laCartaEspañolaEstáTapada()) }

//---------------------------------------------------------------------------------------------------/
/*------------------------ Operaciones de E/S de cartas españolas (interfaz) ------------------------/
/---------------------------------------------------------------------------------------------------*/
function  leerCarta()                 { return(aux_leerCartaEspañola())       }
procedure PonerCarta_(carta)          { AuxPonerCartaEspañolaDestapada(carta) }
procedure SacarCartaActual()          { AuxSacarCartaEspañolaActual()         }

procedure DarVueltaLaCartaActual()    { AuxDarVueltaLaCartaEspañolaActual()   }
procedure PonerCartaDestapada_(carta) { AuxPonerCartaEspañolaDestapada(carta) }
procedure PonerCartaTapada_(carta)    { AuxPonerCartaEspañolaTapada(carta)    }

//---------------------------------------------------------------------------------------------------/
/*------------------------ Operaciones específicas para MEMOTEST (interfaz) -------------------------/
/---------------------------------------------------------------------------------------------------*/
// DE SENSADO
function laCartaEstáIluminada()             { return(aux_laCartaEspañolaEstáIluminadaConBoom())      }
function hayCartaDestapadaSinIluminar()     { return(aux_hayCartaEspañolaDestapadaSinIluminar())     }
function hayOtraCartaDestapadaSinIluminar() { return(aux_hayOtraCartaEspañolaDestapadaSinIluminar()) }

// De E/S
procedure IluminarLaCartaActual()     { AuxIluminarLaCartaEspañolaActual()    }

/*==================================================================================================*/
/*-------------------------- FIN INTERFAZ de 03-CartasEspañolas-Base.gbs ---------------------------*/
/*==================================================================================================*/


/*==================================================================================================*/
/*--------------------------- AUXILIARES de 03-CartasEspañolas-Base.gbs ----------------------------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*------------------------ Auxiliares para construir cartas españolas -------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_armarComodín() { return(Comodín) }
function aux_armarCartaEspañola(valor,palo) {
  // PRECONDICIÓN: valor y palo corresponden a los de una carta válida
  if (not aux_esValorDeCartaEspañola(valor)) { BOOM("No existen cartas de ese valor") }
  return(Carta(valor <- valor, palo <- palo)) 
}

//---------------------------------------------------------------------------------------------------/
/*0------------------------ Auxiliares para acceso a cartas españolas -------------------------------/
/---------------------------------------------------------------------------------------------------*/
// BÁSICAS
function aux_esComodín(carta) { return(carta==aux_armarComodín()) }

function aux_dameElPalo(carta) { 
  // PRECONDICIÓN: la carta no es el comodín
  if (aux_esComodín(carta)) { BOOM("El comodín no tiene palo") }
  return(palo(carta)) 
}

function aux_dameElValor(carta) { 
  // PRECONDICIÓN: la carta no es el comodín
  if (aux_esComodín(carta)) { BOOM("El comodín no tiene valor") }
  return(valor(carta)) 
}

// ESTÁNDAR
function aux_esMenorCartaEspañola(carta1, carta2) {
  return(choose
           /* si la carta1 no es comodín, la carta2 debe serlo, y entonces carta1 es menor,
            y si la carta1 es comodín, la carta1 NO puede ser menor que la carta2 (a lo sumo es igual)
           */
           not aux_esComodín(carta1)                                   when (aux_esComodín(carta1) 
                                                                          || aux_esComodín(carta2))
           aux_esMenorPaloDeCartaEspañola(aux_dameElPalo(carta1)
                                         ,aux_dameElPalo(carta2)) 
        || (aux_dameElPalo(carta1) == aux_dameElPalo(carta2) 
         && aux_esMenorValorDeCartaEspañola(aux_dameElValor(carta1)
                                           ,aux_dameElValor(carta2)))  otherwise
  )
}
         
function aux_esMayorCartaEspañola(carta1, carta2) {
  return(choose
           /* si la carta2 no es comodín, la carta1 debe serlo, y entonces carta1 es mayor
            y si la carta2 es comodín, la carta1 NO puede ser mayor que la carta2 (a lo sumo es igual)
           */
           not aux_esComodín(carta2)                                   when (aux_esComodín(carta1) 
                                                                          || aux_esComodín(carta2))
           aux_esMayorPaloDeCartaEspañola(aux_dameElPalo(carta1)
                                         ,aux_dameElPalo(carta2)) 
        || (aux_dameElPalo(carta1) == aux_dameElPalo(carta2) 
         && aux_esMayorValorDeCartaEspañola(aux_dameElValor(carta1)
                                           ,aux_dameElValor(carta2)))  otherwise
  )
}
         
function aux_minCartaEspañola() { return(aux_armarCartaEspañola(aux_minValorDeCartaEspañola()
                                                              , aux_minPaloDeCartaEspañola())) }
function aux_maxCartaEspañola() { return(aux_armarComodín())                                   }
         
function aux_cartaEspañolaSiguiente(carta) {
  if (carta == aux_maxCartaEspañola())
        { resultado := aux_minCartaEspañola() }
   else { // aux_maxCartaEspañola() es el Comodín, y entonces se puede usar valor y palo
      valorCarta := aux_dameElValor(carta)
      paloCarta := aux_dameElPalo(carta)
      if     (valorCarta < aux_maxValorDeCartaEspañola())
        { resultado := aux_armarCartaEspañola(aux_valorDeCartaEspañolaSiguiente(valorCarta), paloCarta) }
      elseif (valorCarta == aux_maxValorDeCartaEspañola() && paloCarta < aux_maxPaloDeCartaEspañola())
        { resultado := aux_armarCartaEspañola(aux_minValorDeCartaEspañola(), aux_paloDeCartaEspañolaSiguiente(paloCarta)) }
      else // (valorCarta == aux_maxValorDeCartaEspañola() && paloCarta == aux_maxPaloDeCartaEspañola())
        { resultado := aux_armarComodín() }
   }
   return(resultado)
}

function aux_cartaEspañolaPrevia(carta) {
  if (carta == aux_minCartaEspañola())
        { resultado := aux_maxCartaEspañola() }
   elseif (aux_esComodín(carta))
        { resultado := aux_armarCartaEspañola(aux_maxValorDeCartaEspañola(), aux_maxPaloDeCartaEspañola()) }
   else {
      valorCarta := aux_dameElValor(carta)
      paloCarta := aux_dameElPalo(carta)
      if     (valorCarta > aux_minValorDeCartaEspañola())
        { resultado := aux_armarCartaEspañola(aux_valorDeCartaEspañolaPrevio(valorCarta), paloCarta) }
      else // (valorCarta == aux_minValorDeCartaEspañola() && paloCarta > aux_minPaloDeCartaEspañola())
           //  porque si son iguales, sería aux_minCartaEspañola() que se descartó en el primer if
        { resultado := aux_armarCartaEspañola(aux_minValorDeCartaEspañola(), aux_paloDeCartaEspañolaSiguiente(paloCarta)) }
   }
   return(resultado)
}

//---------------------------------------------------------------------------------------------------/
/*----------------------- Auxiliares para sensar cartas españolas en el tablero ---------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_hayCartaEspañola() { return (aux_hayTipoCartaEspañola() && aux_hayDatoCartaEspañola()) }

function aux_hayTipoCartaEspañola() { return (aux_esTipoCartaEspañola(aux_leerTipo())) }
function aux_hayDatoCartaEspañola() { return (aux_esDatoCartaEspañola(aux_leerDato())) }

function aux_laCartaEspañolaEstáTapada() { 
  // PRECONDICIÓN: hay una carta española
  return (aux_hayAtributoReverso())
}

function aux_laCartaEspañolaEstáTapadaConBoom() { 
  if (not aux_hayCartaEspañola()) { BOOM("No hay una carta que pueda estar tapada") }
  return(aux_laCartaEspañolaEstáTapada())    
}

function aux_hayCartaEspañolaDestapada() { 
  return (aux_hayCartaEspañola()           
       && not aux_laCartaEspañolaEstáTapada())
}

//---------------------------------------------------------------------------------------------------/
/*-------------------------- Operaciones de E/S de cartas españolas ---------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_leerCartaEspañola() {
  // PRECONDICIÓN: hay una carta destapada en la celda actual
  if (not aux_hayCartaEspañola())      { BOOM("No hay una carta española que pueda leer") }
  if (aux_laCartaEspañolaEstáTapada()) { BOOM("No puedo leer una carta española tapada")  }
  return(aux_cartaEspañolaParaElCódigo(aux_leerDato()))
}         

procedure AuxPonerCartaEspañolaTapada(carta) {
  // PRECONDICIÓN: no hay una carta española en la celda actual
  /* El BOOM lo hace AuxPonerCartaEspañolaDestapada
  // if (aux_hayCartaEspañola()) { BOOM("No puedo bajar una carta española donde ya hay una") } 
  */
  AuxPonerCartaEspañolaDestapada(carta)
  AuxTaparLaCartaEspañolaActual()   // La carta recién puesta no está iluminada
}

procedure AuxPonerCartaEspañolaDestapada(carta) {
  // PRECONDICIÓN: no hay una carta en la celda actual
  if (aux_hayCartaEspañola()) { BOOM("No puedo bajar una carta española donde ya hay una") }
  AuxSacarTodas()
  AuxPonerRepresentaciónParaLaCartaEspañola(carta)
}

procedure AuxSacarCartaEspañolaActual() {
  // PRECONDICIÓN: hay una carta destapada en la celda actual
  if (not aux_hayCartaEspañola())       { BOOM("No hay una carta que pueda sacar") }
  if (aux_laCartaEspañolaEstáTapada())  { BOOM("No puedo sacar una carta tapada")  }
  AuxSacarRepresentaciónParaLaCartaEspañola()
}

procedure AuxDarVueltaLaCartaEspañolaActual() {
  if (not aux_hayCartaEspañola())         { BOOM("No hay una carta que pueda girar")   }
  if (not aux_laCartaEspañolaEstáTapada()  // Para garantizar el invariante de la condición siguiente
   && aux_laCartaEspañolaEstáIluminada()) { BOOM("No puedo girar una carta iluminada") }
  if (aux_laCartaEspañolaEstáTapada()) 
       { AuxDestaparLaCartaEspañolaActual() }
  else { AuxTaparLaCartaEspañolaActual()    }
}

procedure AuxTaparLaCartaEspañolaActual()    { 
 // PRECONDICIÓN: hay una carta española destapada y no iluminada en la celda actual
  AuxPonerAtributoReverso()
}

procedure AuxDestaparLaCartaEspañolaActual() { 
 // PRECONDICIÓN: hay una carta española tapada en la celda actual
  AuxSacarAtributoReverso()
}

//---------------------------------------------------------------------------------------------------/
/*--------------------------- Operaciones auxiliares de codificación --------------------------------/
/---------------------------------------------------------------------------------------------------*/
// ESPECÍFICAS
function aux_esCódigoParaElComodín(códigoComodín) { return (códigoComodín == aux_códigoParaElComodín()) }
function aux_códigoParaElComodín() { return (aux_maxCódigoParaElPaloDeCartaEspañola()+1) }
// LA CODIFICACIÓN DE CARTAS ESTÁ TODA JUNTA EN las funciones que siguen y en aux_códigoParaLaCartaEspañola
// El comodín va después del último palo

function aux_analizarDatoCarta(códigoCartaEspañola) {
  return (códigoCartaEspañola mod 100, códigoCartaEspañola div 100)
}

function aux_producirDatoCarta(códigoValor, códigoPalo) {
  /* PRECONDICIÓN: códigoValor es un código de carta española válido, 
                 y códigoPalo es un código de palo de carta española válido
  */
 if (not (aux_sonValorYPaloDeCartaEspañola(códigoValor, códigoPalo))) { BOOM("El código del valor o del palo no es válido") }
 return (choose
            100*códigoPalo                when (aux_esCódigoParaElComodín(códigoPalo))
            100*códigoPalo + códigoValor  otherwise
         )
}

function aux_sonValorYPaloDeCartaEspañola(códigoValor, códigoPalo) {
  return(aux_esCódigoParaElComodín(códigoPalo) || 
         (aux_esCódigoParaElValorDeCartaEspañola(códigoValor) 
       && aux_esCódigoParaElPaloDeCartaEspañola(códigoPalo))
        )
}

// ESTÁNDAR
function aux_minCódigoParaLaCartaEspañola() { return(aux_códigoParaLaCartaEspañola(aux_minCartaEspañola())) }
function aux_maxCódigoParaLaCartaEspañola() { return(aux_códigoParaLaCartaEspañola(aux_maxCartaEspañola())) }

function aux_esCódigoParaLaCartaEspañola(códigoCartaEspañola) {
  let (códigoValor, códigoPalo) := aux_analizarDatoCarta(códigoCartaEspañola)
  return (aux_sonValorYPaloDeCartaEspañola(códigoValor, códigoPalo))
}

function aux_códigoParaLaCartaEspañola(carta) { 
  return(choose
           aux_producirDatoCarta(0, aux_códigoParaElComodín())                      when (aux_esComodín(carta))
           aux_producirDatoCarta(aux_códigoParaElValorDeCartaEspañola(valor(carta))
                                ,aux_códigoParaElPaloDeCartaEspañola(palo(carta)))  otherwise
        ) 
}

function aux_cartaEspañolaParaElCódigo(códigoCarta) {
  // PRECONDICIÓN: el códigoDatoCarta corresponde a los de una carta válida
  if (not aux_esCódigoParaLaCartaEspañola(códigoCarta)) { BOOM("No es un código de carta válido") }
  let (códigoValor, códigoPalo) := aux_analizarDatoCarta(códigoCarta)
  return(choose
           aux_armarComodín()                                    when (aux_esCódigoParaElComodín(códigoPalo))
           aux_armarCartaEspañola(
               aux_valorDeCartaEspañolaParaElCódigo(códigoValor)
              ,aux_paloDeCartaEspañolaParaElCódigo(códigoPalo))  otherwise
  )
}

function aux_códigoParaLaCartaEspañolaSiguiente(carta) { return (aux_códigoParaLaCartaEspañola(aux_cartaEspañolaSiguiente(carta))) }
function aux_códigoParaLaCartaEspañolaPrevia(carta)    { return (aux_códigoParaLaCartaEspañola(aux_cartaEspañolaPrevia(carta)))    }

//---------------------------------------------------------------------------------------------------/
/*----------------- Operaciones auxiliares de codificación para el tablero --------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_códigoParaElTipoCartaEspañola()      { return(3)                                    }
function aux_códigoParaElDatoCartaEspañola(carta) { return(aux_códigoParaLaCartaEspañola(carta)) }

function aux_esTipoCartaEspañola(código) { return (código == aux_códigoParaElTipoCartaEspañola()) }
function aux_esDatoCartaEspañola(dato)   { return (aux_esCódigoParaLaCartaEspañola(dato)) }

procedure AuxPonerRepresentaciónParaLaCartaEspañola(carta) {
  // PRECONDICIÓN: la celda está vacía
  AuxPoner__Veces(aux_colorParaElTipo(), aux_códigoParaElTipoCartaEspañola()) 
  AuxPoner__Veces(aux_colorParaElDato(), aux_códigoParaElDatoCartaEspañola(carta)) 
}

procedure AuxSacarRepresentaciónParaLaCartaEspañola() { 
   // PRECONDICIÓN: hay una representación de cartas
   AuxSacarTodas() 
}

//---------------------------------------------------------------------------------------------------/
/*-------------------------- Auxiliares de atributos de cartas españolas ----------------------------/
/---------------------------------------------------------------------------------------------------*/
function  aux_códigoParaElAtributoReverso() { return(1) }
function  aux_hayAtributoReverso()  { return (nroBolitas(aux_colorParaElAtributo())==aux_códigoParaElAtributoReverso()) }
procedure AuxPonerAtributoReverso() { Poner__Veces(aux_colorParaElAtributo(), aux_códigoParaElAtributoReverso())        }
procedure AuxSacarAtributoReverso() { Sacar__Veces(aux_colorParaElAtributo(), aux_códigoParaElAtributoReverso())        }

function aux_códigoParaElAtributoIluminación() { return(2) }
function  aux_hayAtributoIluminación()  { return (nroBolitas(aux_colorParaElAtributo())==aux_códigoParaElAtributoIluminación()) }
procedure AuxPonerAtributoIluminación() { Poner__Veces(aux_colorParaElAtributo(), aux_códigoParaElAtributoIluminación())        }
procedure AuxSacarAtributoIluminación() { Sacar__Veces(aux_colorParaElAtributo(), aux_códigoParaElAtributoIluminación())        }

//---------------------------------------------------------------------------------------------------/
/*--------------------------- Auxiliares específicas para MEMOTEST ----------------------------------/
/---------------------------------------------------------------------------------------------------*/
// DE SENSADO
function aux_laCartaEspañolaEstáIluminada() {
  // PRECONDICIÓN: hay una carta española y no está tapada
  return (aux_hayAtributoIluminación())
}

function aux_laCartaEspañolaEstáIluminadaConBoom() { 
  if (not aux_hayCartaEspañola())      { BOOM("No hay una carta española que pueda estar iluminada")     }
  if (aux_laCartaEspañolaEstáTapada()) { BOOM("Las cartas españolas tapadas no pueden estar iluminadas") }
  return(aux_laCartaEspañolaEstáIluminada()) 
}

function aux_hayCartaEspañolaDestapadaSinIluminar() { 
  return (aux_hayCartaEspañola()           
       && not aux_laCartaEspañolaEstáTapada()
       && not aux_laCartaEspañolaEstáIluminada())
}

function aux_hayOtraCartaEspañolaDestapadaSinIluminar() {
  // PRECONDICIÓN: no hay ninguna celda marcada
  AuxMarcar()
  IrAlOrigen()
  while (not aux_terminoElRecorrido() && not aux_hayCartaEspañolaDestapadaSinIluminarYSinMarca()) 
      { AuxPasarASiguientePosición() }
  valorDeRetorno := aux_hayCartaEspañolaDestapadaSinIluminarYSinMarca()
  AuxVolverALaMarca()
  AuxDesmarcar()
  return(valorDeRetorno)
}                                    

function aux_hayCartaEspañolaDestapadaSinIluminarYSinMarca() { 
   return (aux_hayCartaEspañolaDestapadaSinIluminar() && not aux_hayMarca()) 
}

// DE E/S
procedure AuxIluminarLaCartaEspañolaActual() {
  /* PROPÓSITO:
      - si hay una carta destapada sin iluminar, la ilumina.
      - en cualquier otro caso, no hace nada 
        (las cartas tapadas o iluminadas permanecen igual y 
        si no hay carta, no pasa nada)
  */
   if (aux_hayCartaEspañolaDestapadaSinIluminar()) { AuxPonerAtributoIluminación() } 
 }
 
/*==================================================================================================*/
/*------------------------- FIN AUXILIARES de 03-CartasEspañolas-Base.gbs --------------------------*/
/*==================================================================================================*/


/*==================================================================================================*/
/*--------------------------------- REQUIERE 00-Gobstones-Base.gbs ---------------------------------*/
/*==================================================================================================*/

/*==================================================================================================*/
/*------------------------ INTERFAZ de 03-02-ValoresDeCartaEspañola-Base.gbs ------------------------/
/----- Autor: Pablo E. "Fidel" Martínez López -------------------------------------------------------/
/----- EMail: fidel@unq.edu.ar                -------------------------------------------------------/
/----- Fecha creación: 2018.06                -------------------------------------------------------/
/----- Fecha última modificación: 2018.06     -------------------------------------------------------/
/----- Licencia: GNU General Public License, v2                                             ---------/
/----- Sitio Oficial de la licencia: http://www.gnu.org/licenses/old-licenses/gpl-2.0.html  --------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*-------------------------------------- Definiciones de tipos --------------------------------------/
/---------------------------------------------------------------------------------------------------*/
// Los valores de carta española son simplemente números enteros

//---------------------------------------------------------------------------------------------------/
/*----------------------------- Operaciones de creación de valores (interfaz) -----------------------/
/---------------------------------------------------------------------------------------------------*/
{-
///*@ATTRIBUTE@tooltip@Denota el valor de una carta de un mazo de cartas españolas de 50 cartas*/
///*@ATTRIBUTE@block_name@_@*/
///*@ATTRIBUTE@block_dropdown@[("As", '1'), ("2", '2'), ("3", '3'), ("4", '4'), ("5", '5'), ("6", '6'), ("7", '7'), ("8", '8'), ("9", '9'), ("Sota", '10'), ("Caballo", '11'), ("Rey", '12')]@*/
//function valorCartaEspañolaDe50_(valor) { return (valor) }

///*@ATTRIBUTE@tooltip@Denota el valor de una carta de un mazo de cartas españolas de 40 cartas*/
///*@ATTRIBUTE@block_name@_@*/
///*@ATTRIBUTE@block_dropdown@[("As", '1'), ("2", '2'), ("3", '3'), ("4", '4'), ("5", '5'), ("6", '6'), ("7", '7'), ("Sota", '10'), ("Caballo", '11'), ("Rey", '12')]@*/
//function valorCartaEspañolaDe40_(valor) { return (valor) }
-}

/*@ATTRIBUTE@block_name@As@*/       function dameElValorAs()     { return(1) }
/*@ATTRIBUTE@block_name@valor _@*/  function dameElValor_(valor) { 
  if (valor < 2 || valor > 7) { BOOM("No es un valor válido de una carta española de 40 cartas")}
  return(valor) 
}
/*@ATTRIBUTE@block_name@Sota@*/     function dameElValorSota()    { return(10) }
/*@ATTRIBUTE@block_name@Caballo@*/  function dameElValorCaballo() { return(11) }
/*@ATTRIBUTE@block_name@Rey@*/      function dameElValorRey()     { return(12) }

//---------------------------------------------------------------------------------------------------/
/*------------------------------ Operaciones de acceso a valores (interfaz) -------------------------/
/---------------------------------------------------------------------------------------------------*/
/*@ATTRIBUTE@block_name@_ es menor valor que _@*/ function esMenorValor__(valor1, valor2) { return(aux_esMenorValorDeCartaEspañola(valor1, valor2)) }
/*@ATTRIBUTE@block_name@_ es mayor valor que _@*/ function esMayorValor__(valor1, valor2) { return(aux_esMayorValorDeCartaEspañola(valor1, valor2)) }
/*@ATTRIBUTE@block_name@el valor más chico@*/     function minValor()            { return(aux_minValorDeCartaEspañola())            }
/*@ATTRIBUTE@block_name@el valor más grande@*/    function maxValor()            { return(aux_maxValorDeCartaEspañola())            }
/*@ATTRIBUTE@block_name@valor siguiente a _@*/    function valorSiguiente_(palo) { return(aux_valorDeCartaEspañolaSiguiente(valor)) }
/*@ATTRIBUTE@block_name@valor previa a _@*/       function valorPrevio_(palo)    { return(aux_valorDeCartaEspañolaPrevio(valor))    }

//---------------------------------------------------------------------------------------------------/
/*------------------ Operaciones de sensado de valores en el tablero (interfaz) ---------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES DE SENSADO de valores de carta española INDIVIDUALES
   Los valores de carta española son parte del tipo carta española
 */

//---------------------------------------------------------------------------------------------------/
/*--------------------------- Operaciones de E/S de valores (interfaz) ------------------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES DE E/S de valores de carta española INDIVIDUALES
   Los valores de carta española son parte del tipo carta española
 */

/*==================================================================================================*/
/*--------------------- FIN INTERFAZ de 03-02-ValoresDeCartaEspañola-Base.gbs ----------------------*/
/*==================================================================================================*/


/*==================================================================================================*/
/*---------------------- AUXILIARES de 03-02-ValoresDeCartaEspañola-Base.gbs -----------------------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*----------------------------- Auxiliares para construir valores -----------------------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES ESPECÍFICAS DE CONSTRUCCIÓN de valores de carta española
   Se proveen con los constructores del tipo o con la codificación
 */

//---------------------------------------------------------------------------------------------------/
/*------------------------------ Auxiliares para acceso a valores -----------------------------------/
/---------------------------------------------------------------------------------------------------*/
// ¡¡¡¡LOS VALORES SON DIRECTAMENTE SU CÓDIGO!!!! Por eso no están las funciones de decodificación

// ESPECÍFICAS
function aux_esValorDeCartaEspañola(valor)  { return (aux_esCódigoParaElValorDeCartaEspañola(valor)) }

// ESTÁNDAR
function aux_esMenorValorDeCartaEspañola(valor1, valor2) { return (valor1 < valor2) }
function aux_esMayorValorDeCartaEspañola(valor1, valor2) { return (valor1 > valor2) }
  
function aux_minValorDeCartaEspañola() { return (aux_minCódigoParaElValorDeCartaEspañola()) }
function aux_maxValorDeCartaEspañola() { return (aux_maxCódigoParaElValorDeCartaEspañola()) }

function aux_valorDeCartaEspañolaSiguiente(valor) { return (aux_códigoParaElValorDeCartaEspañolaSiguiente(valor)) }
function aux_valorDeCartaEspañolaPrevio(valor)    { return (aux_códigoParaElValorDeCartaEspañolaPrevio(valor))    }

//---------------------------------------------------------------------------------------------------/
/*------------------ Auxiliares para sensar valores de carta española en el tablero -----------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES DE SENSADO de valores de carta española INDIVIDUALES
   Los valores de carta española son parte del tipo carta española
 */

//---------------------------------------------------------------------------------------------------/
/*---------------------- Operaciones de E/S de valores de carta española ----------------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES DE SENSADO de valores de carta española INDIVIDUALES
   Los valores de carta española son parte del tipo carta española
 */

//---------------------------------------------------------------------------------------------------/
/*---------------------------- Operaciones auxiliares de codificación -------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_minCódigoParaElValorDeCartaEspañola() { return (1)  }
function aux_maxCódigoParaElValorDeCartaEspañola() { return (12) }

function aux_esCódigoParaElValorDeCartaEspañola(códigoValor) {   
  return (códigoValor >= aux_minCódigoParaElValorDeCartaEspañola() 
       && códigoValor <= aux_maxCódigoParaElValorDeCartaEspañola())
}

function aux_códigoParaElValorDeCartaEspañola(valor)  { 
  if (not aux_esValorDeCartaEspañola(valor)) { BOOM("No es un valor válido para una carta española") }
  return (valor) 
}

function aux_valorDeCartaEspañolaParaElCódigo(códigoValor) { 
  if (not aux_esCódigoParaElValorDeCartaEspañola(valor)) { BOOM("No es un código válido para el valor de una carta española") }
  return (códigoValor) 
}

function aux_códigoParaElValorDeCartaEspañolaSiguiente(valor) {
  return (choose 
           aux_minCódigoParaElValorDeCartaEspañola()  when (valor == aux_maxCódigoParaElValorDeCartaEspañola())
           valor+1                                    otherwise
         )
}

function aux_códigoParaElValorDeCartaEspañolaPrevio(valor) {
  return (choose 
           aux_maxCódigoParaElValorDeCartaEspañola()  when (valor == aux_minCódigoParaElValorDeCartaEspañola())
           valor-1                                    otherwise
         )
}


//---------------------------------------------------------------------------------------------------/
/*----------------------- Operaciones auxiliares de codificación para el tablero --------------------/
/---------------------------------------------------------------------------------------------------*/
// LOS VALORES DE CARTA ESPAÑOLA NO SE REPRESENTAN EN EL TABLERO

/*==================================================================================================*/
/*-------------------- FIN AUXILIARES de 03-02-ValoresDeCartaEspañola-Base.gbs ---------------------*/
/*==================================================================================================*/


/*==================================================================================================*/
/*--------------------------------- REQUIERE 00-Gobstones-Base.gbs ---------------------------------*/
/*==================================================================================================*/

/*==================================================================================================*/
/*------------------------- INTERFAZ de 03-01-PalosDeCartaEspañola-Base.gbs -------------------------/
/----- Autor: Pablo E. "Fidel" Martínez López -------------------------------------------------------/
/----- EMail: fidel@unq.edu.ar                -------------------------------------------------------/
/----- Fecha creación: 2018.06                -------------------------------------------------------/
/----- Fecha última modificación: 2018.06     -------------------------------------------------------/
/----- Licencia: GNU General Public License, v2                                             ---------/
/----- Sitio Oficial de la licencia: http://www.gnu.org/licenses/old-licenses/gpl-2.0.html  --------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*-------------------------------------- Definiciones de tipos --------------------------------------/
/---------------------------------------------------------------------------------------------------*/
type PaloDeCartaEspañola  is variant { case Espadas {} case Oros {} case Bastos {} case Copas {} }

//---------------------------------------------------------------------------------------------------/
/*------------------------------ Operaciones de creación de palos (interfaz) ------------------------/
/---------------------------------------------------------------------------------------------------*/
{-
///*@ATTRIBUTE@tooltip@Denota el palo de una carta de un mazo de cartas españolas*/
///*@ATTRIBUTE@block_name@_@*/
///*@ATTRIBUTE@block_dropdown@[("Bastos", 'Bastos'), ("Copas", 'Copas'), ("Espadas", 'Espadas'), ("Oros", 'Oros')]@*/
//function palo_(palo) { return (palo) }
-}

///*@ATTRIBUTE@tooltip@Denota el palo de espadas de un mazo de cartas españolas*/
/*@ATTRIBUTE@block_name@Espadas@*/function espadas() { return(Espadas) }
/*@ATTRIBUTE@block_name@Oros@*/   function oros()    { return(Oros)    }
/*@ATTRIBUTE@block_name@Bastos@*/ function bastos()  { return(Bastos)  }
/*@ATTRIBUTE@block_name@Copas@*/  function copas()   { return(Copas)   }

//---------------------------------------------------------------------------------------------------/
/*------------------------------- Operaciones de acceso a palos (interfaz) --------------------------/
/---------------------------------------------------------------------------------------------------*/
/*@ATTRIBUTE@block_name@_ es menor palo que _@*/ function esMenorPalo__(palo1, palo2) { return(aux_esMenorPaloDeCartaEspañola(palo1, palo2)) }
/*@ATTRIBUTE@block_name@_ es mayor palo que _@*/ function esMayorPalo__(palo1, palo2) { return(aux_esMayorPaloDeCartaEspañola(palo1, palo2)) }
/*@ATTRIBUTE@block_name@el palo más chico@*/     function minPalo()            { return(aux_minPaloDeCartaEspañola())           }
/*@ATTRIBUTE@block_name@el palo más grande@*/    function maxPalo()            { return(aux_maxPaloDeCartaEspañola())           }
/*@ATTRIBUTE@block_name@palo siguiente a _@*/    function paloSiguiente_(palo) { return(aux_paloDeCartaEspañolaSiguiente(palo)) }
/*@ATTRIBUTE@block_name@palo previo a _@*/       function paloPrevio_(palo)    { return(aux_paloDeCartaEspañolaPrevio(palo))    }

//---------------------------------------------------------------------------------------------------/
/*------------------- Operaciones de sensado de palos en el tablero (interfaz) ----------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES DE SENSADO de palos de carta española INDIVIDUALES
   Los palos de carta española son parte del tipo carta española
 */

//---------------------------------------------------------------------------------------------------/
/*---------------------------- Operaciones de E/S de palos (interfaz) -------------------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES DE E/S de palos de carta española INDIVIDUALES
   Los palos de carta española son parte del tipo carta española
 */

/*==================================================================================================*/
/*---------------------- FIN INTERFAZ de 03-01-PalosDeCartaEspañola-Base.gbs -----------------------*/
/*==================================================================================================*/


/*==================================================================================================*/
/*----------------------- AUXILIARES de 03-01-PalosDeCartaEspañola-Base.gbs ------------------------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*------------------------------ Auxiliares para construir palos ------------------------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES ESPECÍFICAS DE CONSTRUCCIÓN de palos de carta española
   Se proveen con los constructores del tipo o con la codificación
 */

//---------------------------------------------------------------------------------------------------/
/*------------------------------- Auxiliares para acceso a palos ------------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_esMenorPaloDeCartaEspañola(palo1, palo2) { return (aux_códigoParaElPaloDeCartaEspañola(palo1) < aux_códigoParaElPaloDeCartaEspañola(palo2)) }
function aux_esMayorPaloDeCartaEspañola(palo1, palo2) { return (aux_códigoParaElPaloDeCartaEspañola(palo1) > aux_códigoParaElPaloDeCartaEspañola(palo2)) }

function aux_minPaloDeCartaEspañola() { return (aux_paloDeCartaEspañolaParaElCódigo(aux_minCódigoParaElPaloDeCartaEspañola())) }
function aux_maxPaloDeCartaEspañola() { return (aux_paloDeCartaEspañolaParaElCódigo(aux_maxCódigoParaElPaloDeCartaEspañola())) }

function aux_paloDeCartaEspañolaSiguiente(palo) { return (aux_paloDeCartaEspañolaParaElCódigo(aux_códigoParaElPaloDeCartaEspañolaSiguiente(palo))) }
function aux_paloDeCartaEspañolaPrevio(palo)    { return (aux_paloDeCartaEspañolaParaElCódigo(aux_códigoParaElPaloDeCartaEspañolaPrevio(palo)))    }

//---------------------------------------------------------------------------------------------------/
/*------------------- Auxiliares para sensar palos de carta española en el tablero ------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES DE SENSADO de palosDeCartaEspañola INDIVIDUALES
   Los palosDeCartaEspañola son parte del tipo cartaEspañola
 */

//---------------------------------------------------------------------------------------------------/
/*----------------------- Operaciones de E/S de palos de carta española -----------------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES DE SENSADO de palos de carta española INDIVIDUALES
   Los palos de carta española son parte del tipo carta española
 */

//---------------------------------------------------------------------------------------------------/
/*---------------------------- Operaciones auxiliares de codificación -------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_minCódigoParaElPaloDeCartaEspañola() { return (1) }
function aux_maxCódigoParaElPaloDeCartaEspañola() { return (4) }

function aux_esCódigoParaElPaloDeCartaEspañola(códigoPalo) {   
  return (códigoPalo >= aux_minCódigoParaElPaloDeCartaEspañola() 
       && códigoPalo <= aux_maxCódigoParaElPaloDeCartaEspañola())
}

function aux_códigoParaElPaloDeCartaEspañola(palo) { 
  return (choose 
     1 when (palo == Bastos )
     2 when (palo == Copas  )
     3 when (palo == Espadas)
     4 when (palo == Oros   )
     boom("Al extender los palos de carta española, deberías extender también las funciones de codificación") otherwise
  )
}

function aux_paloDeCartaEspañolaParaElCódigo(códigoPalo) {
  // PRECONDICIÓN: el código es válido, o sea, corresponde a un palo de carta española
  //              (está entre aux_minCódigoParaElPaloDeCartaEspañola() y aux_maxCódigoParaElPaloDeCartaEspañola())
  if (not aux_esCódigoParaElPaloDeCartaEspañola(códigoPalo)) { BOOM("No es un código de palo de carta española válido") }
  return (choose
     Bastos  when (códigoPalo == 1)
     Copas   when (códigoPalo == 2)
     Espadas when (códigoPalo == 3)
     Oros    when (códigoPalo == 4)
     boom("¡NO DEBERÍA SUCEDER! Revisar esCódigoParaElPaloDeCartaEspañola.") otherwise
  )
}

function aux_códigoParaElPaloDeCartaEspañolaSiguiente(palo) {
  códigoPalo := aux_códigoParaElPaloDeCartaEspañola(palo)
  return (choose 
           aux_minCódigoParaElPaloDeCartaEspañola()  when (códigoPalo == aux_maxCódigoParaElPaloDeCartaEspañola())
           códigoPalo+1                              otherwise
         )
}

function aux_códigoParaElPaloDeCartaEspañolaPrevio(palo) {
  códigoPalo := aux_códigoParaElPaloDeCartaEspañola(palo)
  return (choose 
           aux_maxCódigoParaElPaloDeCartaEspañola()  when (códigoPalo == aux_minCódigoParaElPaloDeCartaEspañola())
           códigoPalo-1                              otherwise
         )
}

//---------------------------------------------------------------------------------------------------/
/*----------------------- Operaciones auxiliares de codificación para el tablero --------------------/
/---------------------------------------------------------------------------------------------------*/
// LOS PALOS DE CARTA ESPAÑOLA NO SE REPRESENTAN EN EL TABLERO

/*==================================================================================================*/
/*--------------------- FIN AUXILIARES de 03-01-PalosDeCartaEspañola-Base.gbs ----------------------*/
/*==================================================================================================*/


/*==================================================================================================*/
/*------------------------------- INTERFAZ de 00.Gobstones-Base.gbs ---------------------------------/
/----- Autor: Pablo E. "Fidel" Martínez López -------------------------------------------------------/
/----- EMail: fidel@unq.edu.ar                -------------------------------------------------------/
/----- Fecha creación: 2018.06                -------------------------------------------------------/
/----- Fecha última modificación: 2018.06     -------------------------------------------------------/
/----- Licencia: GNU General Public License, v2                                             ---------/
/----- Sitio Oficial de la licencia: http://www.gnu.org/licenses/old-licenses/gpl-2.0.html  --------*/
/*==================================================================================================*/
/*@ATTRIBUTE@block_name@Poner _, _ veces@*/ procedure Poner__Veces(c,n) { AuxPoner__Veces(c,n) }
/*@ATTRIBUTE@block_name@Sacar _, _ veces@*/ procedure Sacar__Veces(c,n) { AuxSacar__Veces(c,n) }
/*@ATTRIBUTE@block_name@Mover _, _ veces@*/ procedure Mover__Veces(d,n) { AuxMover__Veces(d,n) }
procedure SacarTodas()   { AuxSacarTodas()   }
procedure SacarTodas_(c) { AuxSacarTodas_(c) }

procedure IrAlOrigen()   { AuxIrAlOrigen()   }

procedure PasarASiguientePosiciónHacia_(dir) { AuxPasarASiguientePosiciónHacia(dir) }
procedure PasarASiguientePosición()          { AuxPasarASiguientePosición()         }
/*==================================================================================================*/
/*----------------------------- FIN INTERFAZ de 00.Gobstones-Base.gbs ------------------------------*/
/*==================================================================================================*/

/*==================================================================================================*/
/*------------------------------ AUXILIARES de 00-Gobstones-Base.gbs -------------------------------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*----------------------------- Operaciones auxiliares de Gobstones ---------------------------------/
/---------------------------------------------------------------------------------------------------*/
procedure AuxPoner__Veces(c,n) { repeat (n) { Poner(c) } }
procedure AuxSacar__Veces(c,n) { repeat (n) { Sacar(c) } }
procedure AuxMover__Veces(d,n) { repeat (n) { Mover(d) } }

procedure AuxSacarTodas()   { foreach c in [minColor()..maxColor()] { AuxSacarTodas_(c) } }
procedure AuxSacarTodas_(c) { AuxSacar__Veces(c, nroBolitas(c)) }

procedure AuxIrAlOrigen()   { IrAlBorde(Sur) IrAlBorde(Oeste) }

//---------------------------------------------------------------------------------------------------/
/*---------------------------- Operaciones auxiliares de codificación -------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_colorParaElDato()     { return(Negro) }
function aux_colorParaElTipo()     { return(Azul)  }
function aux_colorParaElAtributo() { return(Rojo)  }
function aux_colorParaLaMarca()    { return(Verde) }

function aux_leerTipo()     { return(nroBolitas(aux_colorParaElTipo()))     }
function aux_leerDato()     { return(nroBolitas(aux_colorParaElDato()))     }
function aux_leerAtributo() { return(nroBolitas(aux_colorParaElAtributo())) }
function aux_leerMarca()    { return(nroBolitas(aux_colorParaLaMarca()))    }

//---------------------------------------------------------------------------------------------------/
/*--------------------------------- Operaciones de movimiento ---------------------------------------/
/---------------------------------------------------------------------------------------------------*/
procedure AuxPasarASiguientePosiciónHacia(dir) { if (puedeMover(dir)) { Mover(dir) } }
procedure AuxPasarASiguientePosición() {
    if     (puedeMover(Este))  { Mover(Este)                     }
    elseif (puedeMover(Norte)) { IrAlBorde(Oeste) Mover(Norte)   }
    else                       { IrAlBorde(Oeste) IrAlBorde(Sur) }
}

//---------------------------------------------------------------------------------------------------/
/*---------------------------------- Operaciones de recorrido ---------------------------------------/
/---------------------------------------------------------------------------------------------------*/
// La marca son 100 bolitas del aux_colorParaMarca, pero puede haber otras marcas antes
function  aux_códigoDeLaMarca() { return(100) }
function  aux_hayMarca() { return (nroBolitas(aux_colorParaLaMarca())>aux_códigoDeLaMarca()) }
procedure AuxMarcar()    { AuxPoner__Veces(aux_colorParaLaMarca(),aux_códigoDeLaMarca())     }
procedure AuxDesmarcar() { 
  // PRECONDICIÓN: hay una marca en el lugar (o sea, aux_hayMarca() es verdadero)
  AuxSacar__Veces(aux_colorParaLaMarca(),aux_códigoDeLaMarca()) 
}

procedure AuxVolverALaMarca() {
  // PRECONDICIÓN: hay una marca en el tablero
  AuxIrAlOrigen()
  while (not aux_terminoElRecorrido() && not aux_hayMarca()) { AuxPasarASiguientePosición() }
}

function aux_terminoElRecorrido() { return (not puedeMover(Este) && not puedeMover(Norte)) }
/*==================================================================================================*/
/*---------------------------- FIN AUXILIARES de 00-Gobstones-Base.gbs -----------------------------*/
/*==================================================================================================*/




/*==================================================================================================*/
/*--------------------------------- REQUIERE 00-Gobstones-Base.gbs ---------------------------------*/
/*==================================================================================================*/

/*==================================================================================================*/
/*--------------------------------- INTERFAZ de 01-Letras-Base.gbs ----------------------------------/
/----- Autor: Pablo E. "Fidel" Martínez López -------------------------------------------------------/
/----- EMail: fidel@unq.edu.ar                -------------------------------------------------------/
/----- Fecha creación: 2018.06                -------------------------------------------------------/
/----- Fecha última modificación: 2018.06     -------------------------------------------------------/
/----- Licencia: GNU General Public License, v2                                             ---------/
/----- Sitio Oficial de la licencia: http://www.gnu.org/licenses/old-licenses/gpl-2.0.html  --------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*-------------------------------------- Definiciones de tipos --------------------------------------/
/---------------------------------------------------------------------------------------------------*/
type Letra is variant { 
   case Espacio {} 
   case A {}    case B {}    case C {}    case D {}    case E {}    case F {}    case G {}    case H {}    case I {}    
   case J {}    case K {}    case L {}    case M {}    case N {}    case Ñ {}    case O {}    case P {}    case Q {}
   case R {}    case S {}    case T {}    case U {}    case V {}    case W {}    case X {}    case Y {}    case Z {}
}

//---------------------------------------------------------------------------------------------------/
/*------------------------------ Operaciones de creación de letras (interfaz) -----------------------/
/---------------------------------------------------------------------------------------------------*/
{-
/*@ATTRIBUTE@tooltip@Denota una letra*/
/*@ATTRIBUTE@block_name@_@*/
/*@ATTRIBUTE@block_dropdown@[(" ", 'Espacio'), ("A", 'A'), ("B", 'B'), ("C", 'C'), ("D", 'D'), ("E", 'E'), ("F", 'F'), ("G", 'G'), ("H", 'H'), ("I", 'I'), ("J", 'J'), ("K", 'K'), ("L", 'L'), ("M", 'M'), ("N", 'N'), ("Ñ", 'Ñ'), ("O", 'O'), ("P", 'P'), ("Q", 'Q'), ("R", 'R'), ("S", 'S'), ("T", 'T'), ("U", 'U'), ("V", 'V'), ("W", 'W'), ("X", 'X'), ("Y", 'Y'), ("Z", 'Z')]@*/
function letra_(letra) { return(letra) }
-}

function letra_(códigoLetra) { return(aux_letraParaElCódigo(códigoLetra)) }

//---------------------------------------------------------------------------------------------------/
/*------------------------------- Operaciones de acceso a letras (interfaz) -------------------------/
/---------------------------------------------------------------------------------------------------*/
/*@ATTRIBUTE@block_name@_ está antes que _@*/   function esMenorLetra__(letra1, letra2) { return(aux_esMenorLetra(letra1, letra2)) }
/*@ATTRIBUTE@block_name@_ está después que _@*/ function esMayorLetra__(letra1, letra2) { return(aux_esMayorLetra(letra1, letra2)) }
/*@ATTRIBUTE@block_name@la letra más chica@*/   function minLetra()             { return(aux_minLetra())            }
/*@ATTRIBUTE@block_name@la letra más grande@*/  function maxLetra()             { return(aux_maxLetra())            }
/*@ATTRIBUTE@block_name@letra siguiente a _@*/  function letraSiguiente_(letra) { return(aux_letraSiguiente(letra)) }
/*@ATTRIBUTE@block_name@letra previa a _@*/     function letraPrevia_(letra)    { return(aux_letraPrevia(letra))    }

//---------------------------------------------------------------------------------------------------/
/*------------------- Operaciones de sensado de letras en el tablero (interfaz) ---------------------/
/---------------------------------------------------------------------------------------------------*/
function hayLetra() { return(aux_hayLetra()) }

//---------------------------------------------------------------------------------------------------/
/*---------------------------- Operaciones de E/S de letras (interfaz) ------------------------------/
/---------------------------------------------------------------------------------------------------*/
function  leerLetra()        { return(aux_leerLetra()) }
procedure PonerLetra_(letra) { AuxPonerLetra(letra)    }
procedure SacarLetraActual() { AuxSacarLetraActual()   }

/*==================================================================================================*/
/*------------------------------- FIN INTERFAZ de 01-Letras-Base.gbs -------------------------------*/
/*==================================================================================================*/


/*==================================================================================================*/
/*-------------------------------- AUXILIARES de 01-Letras-Base.gbs --------------------------------*/
/*==================================================================================================*/

//---------------------------------------------------------------------------------------------------/
/*------------------------------ Auxiliares para construir letras ----------------------------------/
/---------------------------------------------------------------------------------------------------*/
/* NO HAY OPERACIONES ESPECÍFICAS DE CONSTRUCCIÓN de Letras
   Se proveen con los constructores del tipo 
 */

//---------------------------------------------------------------------------------------------------/
/*------------------------------- Auxiliares para acceso a letras -----------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_esMenorLetra(letra1, letra2) { return (aux_códigoParaLaLetra(letra1) < aux_códigoParaLaLetra(letra2)) }
function aux_esMayorLetra(letra1, letra2) { return (aux_códigoParaLaLetra(letra1) > aux_códigoParaLaLetra(letra2)) }

function aux_minLetra() { return (aux_letraParaElCódigo(aux_minCódigoParaLaLetra())) }
function aux_maxLetra() { return (aux_letraParaElCódigo(aux_maxCódigoParaLaLetra())) }

function aux_letraSiguiente(letra) { return (aux_letraParaElCódigo(aux_códigoParaLaLetraSiguiente(letra))) }
function aux_letraPrevia(letra)    { return (aux_letraParaElCódigo(aux_códigoParaLaLetraPrevia(letra)))    }

//---------------------------------------------------------------------------------------------------/
/*---------------------------- Auxiliares para sensar letras en el tablero --------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_hayLetra() { 
  return (aux_hayTipoLetra() 
       && aux_hayDatoLetra()) 
}

function aux_hayTipoLetra() { return (aux_esTipoLetra(aux_leerTipo())) }
function aux_hayDatoLetra() { return (aux_esDatoLetra(aux_leerDato())) }

//---------------------------------------------------------------------------------------------------/
/*-------------------------------- Operaciones de E/S de letras -------------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_leerLetra() {
  // PRECONDICIÓN: hay una letra en la celda actual
  if (not (aux_hayLetra()))      { BOOM("No hay una letra que pueda leer") }
  return(aux_letraParaElCódigo(aux_leerDato()))
}         

procedure AuxPonerLetra(letra) {
  AuxSacarTodas()
  AuxPonerRepresentaciónParaLaLetra(letra)
}

procedure AuxSacarLetraActual() {
  // PRECONDICIÓN: hay una letra en la celda actual
  if (not(aux_hayLetra())) { BOOM("No hay una letra que sacar") }
  AuxSacarRepresentaciónParaLaLetra()
}

//---------------------------------------------------------------------------------------------------/
/*---------------------------- Operaciones auxiliares de codificación -------------------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_minCódigoParaLaLetra() { return(10) }
function aux_maxCódigoParaLaLetra() { return(37) }

function aux_esCódigoParaLaLetra(códigoLetra) {
  return (códigoLetra >= aux_minCódigoParaLaLetra() 
       && códigoLetra <= aux_maxCódigoParaLaLetra())
}

function aux_códigoParaLaLetra(letra) {
  return (choose
    10 when (letra == Espacio)
    11 when (letra == A)
    12 when (letra == B)
    13 when (letra == C)
    14 when (letra == D)
    15 when (letra == E)
    16 when (letra == F)
    17 when (letra == G)
    18 when (letra == H)
    19 when (letra == I)
    20 when (letra == J)
    21 when (letra == K)
    22 when (letra == L)
    23 when (letra == M)
    24 when (letra == N)
    25 when (letra == Ñ)
    26 when (letra == O)
    27 when (letra == P)
    28 when (letra == Q)
    29 when (letra == R)
    30 when (letra == S)
    31 when (letra == T)
    32 when (letra == U)
    33 when (letra == V)
    34 when (letra == W)
    35 when (letra == X)
    36 when (letra == Y)
    37 when (letra == Z)
    boom("Al extender las letras, deberías extender también las funciones de codificación") otherwise
    )
}

function aux_letraParaElCódigo(códigoLetra) {
  // PRECONDICIÓN: el código es válido, o sea, corresponde a una letra 
  //               (está entre aux_minCódigoParaLaLetra() y aux_maxCódigoParaLaeLetra())
  if (not aux_esCódigoParaLaLetra(códigoLetra)) { BOOM("No es un código de letra válido") }
  return (choose
            Espacio when (códigoLetra == 10)
            A       when (códigoLetra == 11)
            B       when (códigoLetra == 12)
            C       when (códigoLetra == 13)
            D       when (códigoLetra == 14)
            E       when (códigoLetra == 15)
            F       when (códigoLetra == 16)
            G       when (códigoLetra == 17)
            H       when (códigoLetra == 18)
            I       when (códigoLetra == 19)
            J       when (códigoLetra == 20)
            K       when (códigoLetra == 21)
            L       when (códigoLetra == 22)
            M       when (códigoLetra == 23)
            N       when (códigoLetra == 24)
            Ñ       when (códigoLetra == 25)
            O       when (códigoLetra == 26)
            P       when (códigoLetra == 27)
            Q       when (códigoLetra == 28)
            R       when (códigoLetra == 29)
            S       when (códigoLetra == 30)
            T       when (códigoLetra == 31)
            U       when (códigoLetra == 32)
            V       when (códigoLetra == 33)
            W       when (códigoLetra == 34)
            X       when (códigoLetra == 35)
            Y       when (códigoLetra == 36)
            Z       when (códigoLetra == 37)
            boom("¡NO DEBERÍA SUCEDER! Revisar aux_esCódigoParaLaLetra.") otherwise
          )
}

function aux_códigoParaLaLetraSiguiente(letra) {
  códigoLetra := aux_códigoParaLaLetra(letra)
  return (choose 
           aux_minCódigoParaLaLetra()  when (códigoLetra == aux_maxCódigoParaLaLetra())
           códigoLetra+1               otherwise
         )
}

function aux_códigoParaLaLetraPrevia(letra) {
  códigoLetra := aux_códigoParaLaLetra(letra)
  return (choose 
           aux_maxCódigoParaLaLetra()  when (códigoLetra == aux_minCódigoParaLaLetra())
           códigoLetra-1               otherwise
         )
}


//---------------------------------------------------------------------------------------------------/
/*----------------------- Operaciones auxiliares de codificación para el tablero --------------------/
/---------------------------------------------------------------------------------------------------*/
function aux_códigoParaElTipoLetra()      { return(2)                            }
function aux_códigoParaElDatoLetra(letra) { return(aux_códigoParaLaLetra(letra)) }

function aux_esTipoLetra(código) { return (código == aux_códigoParaElTipoLetra())                                    }
function aux_esDatoLetra(dato)   { return (dato >= aux_minCódigoParaLaLetra() && dato <= aux_maxCódigoParaLaLetra()) }

procedure AuxPonerRepresentaciónParaLaLetra(letra) {
  AuxPoner__Veces(aux_colorParaElTipo(), aux_códigoParaElTipoLetra())
  AuxPoner__Veces(aux_colorParaElDato(), aux_códigoParaLaLetra(letra))
}

procedure AuxSacarRepresentaciónParaLaLetra() {
  // PRECONDICIÓN: hay una letra en la celda actual
  AuxSacarTodas()
}
/*==================================================================================================*/
/*-------------------------------- AUXILIARES de 01-Letras-Base.gbs --------------------------------*/
/*==================================================================================================*/