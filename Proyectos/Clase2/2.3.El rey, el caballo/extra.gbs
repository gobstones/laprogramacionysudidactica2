//--------------------------------
// Definiciones de tipos
//--------------------------------
type Palo  is variant { case Comodín {} case Espadas {} case Oros {} case Bastos {} case Copas {} }
type Carta is record { field palo  field valor  }

//--------------------------------
// Operaciones de palos (interfaz)
//--------------------------------
// /*@ATTRIBUTE@block_name@Oros@*/   function oros()    { return(Oros)    }
// /*@ATTRIBUTE@block_name@Espadas@*/function espadas() { return(Espadas) }
// /*@ATTRIBUTE@block_name@Copas@*/  function copas()   { return(Copas)   }
// /*@ATTRIBUTE@block_name@Bastos@*/ function bastos()  { return(Bastos)  }

//--------------------------------
// Operaciones de cartas (interfaz)
//--------------------------------
// /*@ATTRIBUTE@block_name@dame la Carta _ de _@*/ function dameCarta__(v,p) { return(auxCarta(v, p))    }
// /*@ATTRIBUTE@block_name@dame un comodín@*/      function dameComodín()    { return(auxComodín())      }
// /*@ATTRIBUTE@block_name@es comodín _@*/         function esComodín_(c)    { return(auxEsComodín(c))   }
/*@ATTRIBUTE@block_name@palo de la _@*/            function dameElPalo_(c)   { return(auxDameElPalo(c))  }
/*@ATTRIBUTE@block_name@valor de la _@*/           function dameElValor_(c)  { return(auxDameElValor(c)) }

// function hayCartaTapada()                   { return(auxHayCartaTapada())               }
// function hayCartaDestapadaSinIluminar()     { return(auxHayCartaDestapadaSinIluminar()) }
// function hayOtraCartaDestapadaSinIluminar() { return(auxHayOtraCartaDestapadaSinIluminar()) }

function leerCarta() { return(auxLeerCarta()) }

//--------------------------------
// Operaciones de movimiento (interfaz)
//--------------------------------
procedure TaparCartaActual()              { AuxTaparCartaActual()             }
procedure DestaparCartaActual()           { AuxDestaparCartaActual()          }
// procedure IluminarCartaActual()           { AuxIluminarCartaActual()          }

// procedure BajarCartaTapada_(carta)        { AuxBajarCartaTapada(carta)        }
// procedure BajarCartaDestapada_(carta)     { AuxBajarCartaDestapada(carta)     }

// procedure PasarASiguienteCartaHacia_(dir) { AuxPasarASiguienteCartaHacia(dir) }
procedure PasarASiguienteCarta()          { AuxPasarASiguienteCarta()         }

//--------------------------------
// Operaciones de mazos (interfaz)
//--------------------------------
// function dameLaPrimeraCarta_(mazo) { return(auxDameLaPrimeraCarta(mazo))  }
// function sacarPrimeraCarta_(mazo)  { return(auxSacarLaPrimeraCarta(mazo)) }
// /*@ATTRIBUTE@block_name@quedan cartas en _?@*/ function quedanCartas_(m) { return(auxQuedanCartas(m)) }
// 
// function mazoEspañolChinChon() { return(auxMazoEspañolChinChon()) }
// function mazoEspañolTruco()    { return(auxMazoEspañolTruco())    }

//--------------------------------
// Operaciones auxiliares de cartas
//--------------------------------
function auxComodín()        { return(Carta(palo <- Comodín, valor <- 0)) }

function auxEsComodín(carta) { return(palo(carta)==Comodín) }

function auxCarta(valor,palo) {
  /* PRECONDICIÓN:
      - valor y palo corresponden a los de una carta válida
  */
    if (not (valor >= 1 && valor <= 12)) { BOOM("No existen cartas de ese valor") }
    if (palo == Comodín)                 { BOOM("No podés usar esta operación para obtener el comodín") }
    return(Carta(palo <- palo, valor <- valor)) 
}

function auxDameElPalo(carta) { 
  /* PRECONDICIÓN:
      - la carta no es el comodín
  */
  if (auxEsComodín(carta)) { BOOM("El comodín no tiene palo") }
  return(palo(carta)) 
}

function auxDameElValor(carta) { 
  /* PRECONDICIÓN:
      - la carta no es el comodín
  */
  if (auxEsComodín(carta)) { BOOM("El comodín no tiene valor") }
  return(valor(carta)) 
}

function auxHayCarta()                     { return (hayBolitas(auxColorParaElPalo()) 
                                                  && hayBolitas(auxColorParaElValor())) }     
function auxHayCartaTapada()               { return (auxHayCarta()          &&     auxHayReverso())    }
function auxHayCartaDestapada()            { return (auxHayCarta()          && not auxHayReverso())    }
function auxHayCartaIluminada()            { return (auxHayCartaDestapada() &&     auxEstáIluminada()) }
function auxHayCartaDestapadaSinIluminar() { return (auxHayCartaDestapada() && not auxEstáIluminada()) }

function auxHayOtraCartaDestapadaSinIluminar() {
  /* PRECONDICIÓN:
      - no hay ninguna celda marcada
  */
  AuxMarcar()
  IrAlBorde(Sur) IrAlBorde(Oeste)
  while (not auxTerminoElRecorrido() && not auxHayCartaDestapadaSinIluminarYSinMarca()) 
     { AuxPasarASiguienteCarta() }
  valorDeRetorno := auxHayCartaDestapadaSinIluminarYSinMarca()
  AuxVolverALaMarca()
  AuxDesmarcar()
  return(valorDeRetorno)
}                                    
                                    
//--------------------------------
// Operaciones de mostrado de cartas
//--------------------------------
function auxLeerCarta() {
  /* PRECONDICIÓN:
      - hay una carta destapada en la celda actual
  */
  if (not auxHayCarta())   { BOOM("No hay una carta") }
  if (auxHayCartaTapada()) { BOOM("La carta está tapada") }
  return(Carta(valor <- nroBolitas(auxColorParaElValor())
              ,palo  <- auxPaloParaElCódigo(nroBolitas(auxColorParaElPalo()))
              ))
}         

procedure AuxIluminarCartaActual() 
  { if (auxHayCartaDestapadaSinIluminar()) { Poner(auxColorParaMarca()) } }

procedure AuxDestaparCartaActual() { 
  /* PRECONDICIÓN:
      - hay una carta tapada en la celda actual
  */
  if (not auxHayCarta())       { BOOM("No hay carta para destapar") }
  if (not auxHayCartaTapada()) { BOOM("No hay una carta tapada") }
  Sacar(auxColorParaElReverso()) 
}
procedure AuxTaparCartaActual()    { 
  /* PRECONDICIÓN:
      - hay una carta destapada y no iluminada en la celda actual
  */
  if (not auxHayCarta())          { BOOM("No hay carta para tapar") }
  if (not auxHayCartaDestapada()) { BOOM("No hay una carta destapada") }
  if (auxHayCartaIluminada())     { BOOM("No puedo tapar una carta iluminada") }
  Poner(auxColorParaElReverso()) 
}

procedure AuxBajarCartaTapada(carta) {
  /* PRECONDICIÓN:
      - no hay una carta en la celda actual
  */
  AuxBajarCartaDestapada(carta)
  AuxTaparCartaActual()
}

procedure AuxBajarCartaDestapada(carta) {
  /* PRECONDICIÓN:
      - no hay una carta en la celda actual
  */
  if (auxHayCarta()) { BOOM("No puedo bajar una carta donde ya hay una") }
  AuxSacarTodas()
  AuxPoner__Veces(auxColorParaElValor(), valor(carta)) 
  AuxPoner__Veces(auxColorParaElPalo(), auxCódigoParaElPalo(palo(carta))) 
}

procedure AuxPasarASiguienteCartaHacia(dir) { if (puedeMover(dir)) { Mover(dir) } }
procedure AuxPasarASiguienteCarta() {
    if (puedeMover(Este))      { Mover(Este)                     }
    elseif (puedeMover(Norte)) { IrAlBorde(Oeste) Mover(Norte)   }
    else                       { IrAlBorde(Oeste) IrAlBorde(Sur) }
}

//--------------------------------
// Otras operaciones auxliares
//--------------------------------
function auxHayReverso()                { return (hayBolitas(auxColorParaElReverso())) }
function auxEstáIluminada()             { return (nroBolitas(auxColorParaMarca())==1) }

function auxPaloParaElCódigo(código) {
  /* PRECONDICIÓN:
      - el código es válido, o sea, corresponde a un palo (está entre 1 y 5)
  */
  switch (código) to {
    1 -> { valorDeRetorno := Espadas }
    2 -> { valorDeRetorno := Oros    }
    3 -> { valorDeRetorno := Copas   }
    4 -> { valorDeRetorno := Bastos  }
    5 -> { valorDeRetorno := Comodín }
    _ -> { BOOM("No es un código de palo válido") }
  }
  return(valorDeRetorno)
}

function auxCódigoParaElPalo(palo) { 
  switch (palo) to {
    Espadas -> { valorDeRetorno := 1 }
    Oros    -> { valorDeRetorno := 2 }
    Copas   -> { valorDeRetorno := 3 }
    Bastos  -> { valorDeRetorno := 4 }
    Comodín -> { valorDeRetorno := 5 }
  }
  return(valorDeRetorno)
}
function auxColorParaElPalo()    { return(Negro) }
function auxColorParaElValor()   { return(Azul)  }
function auxColorParaElReverso() { return(Rojo)  }
function auxColorParaMarca()     { return(Verde) }

//--------------------------------
// Operaciones de recorrido
//--------------------------------
function auxHayMarca() { return (nroBolitas(auxColorParaMarca())>1) }
function auxHayCartaDestapadaSinIluminarYSinMarca() 
  { return (auxHayCartaDestapadaSinIluminar() && not auxHayMarca()) }

procedure AuxMarcar()    { AuxPoner__Veces(auxColorParaMarca(),2) }
procedure AuxDesmarcar() { 
  /* PRECONDICIÓN:
      - hay una marca en el lugar (o sea, auxHayMarca() es verdadero)
  */
  AuxSacar__Veces(auxColorParaMarca(),2) 
}

function auxTerminoElRecorrido() { return (not puedeMover(Este) && not puedeMover(Norte)) }

procedure AuxVolverALaMarca() {
  /* PRECONDICIÓN:
      - hay una marca en el tablero
  */
  IrAlBorde(Sur) IrAlBorde(Oeste)
  while (not auxTerminoElRecorrido() && not auxHayMarca()) { PasarASiguienteCarta() }
}

//--------------------------------
// Operaciones auxliares de Gobstones
//--------------------------------
procedure AuxPoner__Veces(c,n) { repeat (n) { Poner(c) } }
procedure AuxSacar__Veces(c,n) { repeat (n) { Sacar(c) } }

procedure AuxSacarTodas()   { foreach c in [Azul..Rojo] { AuxSacarTodas_(c) } }
procedure AuxSacarTodas_(c) { AuxSacar__Veces(c, nroBolitas(c)) }

//--------------------------------
// Operaciones de mazos
//--------------------------------
function auxQuedanCartas(mazo)       { return(not(mazo==[])) }

/* PRECONDICIÓN:
    - quedan cartas en el mazo
*/
function auxDameLaPrimeraCarta(mazo) { return(primero(mazo)) }
function auxSacarPrimeraCarta(mazo)  { return(resto(mazo))   }

function auxMazoEspañolChinChon() {
    mazo := []
    foreach palo in [Espadas, Oros, Copas, Bastos]
      { mazo := mazo ++ auxCartasEspañolasChinChonDe(palo) }
    mazo := mazo ++ [ auxComodín(), auxComodín() ]
    return(mazo)
}

function auxCartasEspañolasChinChonDe(palo) {
    cartasDelPalo := []
    foreach valor in [1..12] 
      { cartasDelPalo := cartasDelPalo ++ [ auxCarta(valor,palo) ] }
    return(cartasDelPalo)
}

function auxMazoEspañolTruco() {
    mazo := []
    foreach palo in [Espadas, Oros, Copas, Bastos] 
      { mazo := mazo ++ auxCartasEspañolasTrucoDe(palo) }
    return(mazo)
}

function auxCartasEspañolasTrucoDe(palo) {
    cartasDelPalo := []
    foreach valor in [1..7]   
      { cartasDelPalo := cartasDelPalo ++ [ auxCarta(valor,palo) ] }
    foreach valor in [10..12] 
      { cartasDelPalo := cartasDelPalo ++ [ auxCarta(valor,palo) ] }
    return(cartasDelPalo)
}
