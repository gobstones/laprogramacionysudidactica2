type Palo is variant { case Comodín {} case Espadas {} case Oros {} case Bastos {} case Copas {} }
type Carta is record { field palo  field valor  }

//--------------------------------
// Operaciones de palos
//--------------------------------
/*@ATTRIBUTE@block_name@Oros@*/function oros() { return(Oros) }

/*@ATTRIBUTE@block_name@Espadas@*/function espadas() { return(Espadas) }

/*@ATTRIBUTE@block_name@Copas@*/function copas() { return(Copas) }

/*@ATTRIBUTE@block_name@Bastos@*/function bastos() { return(Bastos) }

//--------------------------------
// Operaciones de cartas
//--------------------------------
/*@ATTRIBUTE@block_name@dame la Carta _ de _@*/
function carta__(valor,palo) { 
    if (not (valor >= 1 && valor <= 12)) { BOOM("No existen cartas de ese valor") }
    if (palo == Comodín) { BOOM("No podés usar esta operación para obtener el comodín") }
    return(Carta(palo <- palo, valor <- valor)) 
}

/*@ATTRIBUTE@block_name@dame un comodín@*/
function comodín() { 
    return(Carta(palo <- Comodín, valor <- 0)) 
}

/*@ATTRIBUTE@block_name@es comodín _@*/
function esComodín_(carta) { return(palo(carta)==Comodín) }

/*@ATTRIBUTE@block_name@palo de _@*/
function dameElPalo_(carta) { 
  if (palo(carta) == Comodín) { BOOM("El comodín no tiene palo") }
  return(palo(carta)) 
}

/*@ATTRIBUTE@block_name@valor de _@*/
function dameElValor_(carta) { 
  if (palo(carta) == Comodín) { BOOM("El comodín no tiene valor") }
  return(valor(carta)) 
}

function hayCarta() { return (hayBolitas(auxColorParaElPalo()) && hayBolitas(auxColorParaElValor())) }     
function hayCartaTapada()    { return (hayCarta()          &&     auxHayReverso()) }
function hayCartaDestapada() { return (hayCarta()          && not auxHayReverso()) }
function hayCartaIluminada() { return (hayCartaDestapada() && auxEstáIluminada())  }

//--------------------------------
// Operaciones de mostrado de cartas
//--------------------------------
procedure EsperarUnRato() { Poner(auxTardarMucho()) Sacar(auxTardarMucho()) }
function auxTardarMucho() { repeat (100000) { Poner(Rojo) } return(Rojo) }

procedure IluminarCartaActual() { 
  if (hayCartaDestapadaSinIluminar())
     { Poner(auxColorParaMarca()) } 
}
procedure DestaparCartaActual() { 
  if (not hayCarta())       { BOOM("No hay carta para destapar") }
  if (not hayCartaTapada()) { BOOM("No hay una carta tapada") }
  Sacar(auxColorParaElReverso()) 
}
procedure TaparCartaActual()    { 
  if (not hayCarta())          { BOOM("No hay carta para tapar") }
  if (not hayCartaDestapada()) { BOOM("No hay una carta destapada") }
  if (hayCartaIluminada())     { BOOM("No puedo tapar una carta iluminada") }
  Poner(auxColorParaElReverso()) 
}

procedure BajarCartaTapada_(carta) {
  BajarCartaDestapada_(carta)
  TaparCartaActual()
}

procedure BajarCartaDestapada_(carta) {
  if (hayCarta()) { BOOM("No puedo bajar una carta donde ya hay una") }
  AuxSacarTodas()
  AuxPoner__Veces(auxColorParaElValor(), valor(carta)) 
  AuxPoner__Veces(auxColorParaElPalo(), auxCódigoParaElPalo(palo(carta))) 
}

function leerCarta() {
  if (not hayCarta())   { BOOM("No hay una carta") }
  if (hayCartaTapada()) { BOOM("La carta está tapada") }
  return(Carta(valor <- nroBolitas(auxColorParaElValor())
              ,palo  <- auxPaloParaElCódigo(nroBolitas(auxColorParaElPalo()))
              ))
}         

procedure PasarASiguienteCartaHacia_(dir) { if (puedeMover(dir)) { Mover(dir) } }
procedure PasarASiguienteCarta() {
    if (puedeMover(Este)) { Mover(Este) }
    elseif (puedeMover(Norte)) { IrAlBorde(Oeste) Mover(Norte) }
    else { IrAlBorde(Oeste) IrAlBorde(Sur) }
}

function hayOtraCartaDestapada() {
  AuxMarcar()
  IrAlBorde(Sur) IrAlBorde(Oeste)
  while (not auxTerminoElRecorrido() && not auxHayCartaDestapadaSinIluminarYSinMarca()) 
     { PasarASiguienteCarta() }
  ret := auxHayCartaDestapadaSinIluminarYSinMarca()
  AuxVolverALaMarca()
  AuxDesmarcar()
  return (ret)
}                                    
                                    
//--------------------------------
// Operaciones auxliares
//--------------------------------
function auxHayReverso()                { return (hayBolitas(auxColorParaElReverso())) }
function auxEstáIluminada()             { return (nroBolitas(auxColorParaMarca())==1) }

function auxPaloParaElCódigo(código) {
  switch (código) to {
    1 -> { ret := Espadas }
    2 -> { ret := Oros    }
    3 -> { ret := Copas   }
    4 -> { ret := Bastos  }
    5 -> { ret := Comodín }
    _ -> { BOOM("No es un código de palo válido") }
  }
  return (ret)
}

function auxCódigoParaElPalo(palo) { 
  switch (palo) to {
    Espadas -> { ret := 1 }
    Oros    -> { ret := 2 }
    Copas   -> { ret := 3 }
    Bastos  -> { ret := 4 }
    Comodín -> { ret := 5 }
  }
  return (ret)
}
function auxColorParaElPalo()    { return(Negro) }
function auxColorParaElValor()   { return(Azul)  }
function auxColorParaElReverso() { return(Rojo)  }
function auxColorParaMarca()     { return(Verde) }

procedure AuxPoner__Veces(c,n) { repeat (n) { Poner(c) } }
procedure AuxSacar__Veces(c,n) { repeat (n) { Sacar(c) } }

procedure AuxSacarTodas() { foreach c in [Azul..Rojo] { AuxSacarTodas_(c) } }
procedure AuxSacarTodas_(c) { AuxSacar__Veces(c, nroBolitas(c)) }

//--------------------------------
// Operaciones de recorrido
//--------------------------------
function auxHayMarca() { return (nroBolitas(auxColorParaMarca())>1) }
function auxHayCartaDestapadaSinIluminarYSinMarca() 
  { return (hayCartaDestapadaSinIluminar() && not auxHayMarca()) }

procedure AuxMarcar()    { AuxPoner__Veces(auxColorParaMarca(),2) }
procedure AuxDesmarcar() { AuxSacar__Veces(auxColorParaMarca(),2) }

function auxTerminoElRecorrido() { return (not puedeMover(Este) && not puedeMover(Norte)) }

procedure AuxVolverALaMarca() {
  IrAlBorde(Sur) IrAlBorde(Oeste)
  while (not auxTerminoElRecorrido() && not auxHayMarca()) { PasarASiguienteCarta() }
}

/*
//--------------------------------
// Operaciones de mazos
//--------------------------------
function dameLaPrimeraCarta_(mazo) { return(primero(mazo)) }
function sacarPrimeraCarta_(mazo) { return(resto(mazo)) }

/*@ATTRIBUTE@block_name@quedan cartas en _?@*/
function quedanCartas_(mazo) { return(not(mazo==[])) }

function mazoEspañolChinChon() {
    mazo := []
    foreach palo in [Espadas, Oros, Copas, Bastos] {
        foreach valor in [1..12] {
            mazo := mazo ++ [ carta__(valor,palo) ]
        }
    }
    mazo := mazo ++ [ comodín(), comodín() ]
    return(mazo)
}

function mazoEspañolTruco() {
    mazo := []
    foreach palo in [Espadas, Oros, Copas, Bastos] {
        foreach valor in [1..7] {
            mazo := mazo ++ [ carta__(valor,palo) ]
        }
        foreach valor in [10..12] {
            mazo := mazo ++ [ carta__(valor,palo) ]
        }
    }
    return(mazo)
}
*/
