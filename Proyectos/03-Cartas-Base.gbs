//--------------------------------
// REQUIERE 00-Gobstones-Base.gbs
//--------------------------------

//--------------------------------
//--------------------------------
// INTERFAZ de 03-Cartas-Base.gbs
//--------------------------------
//--------------------------------

//--------------------------------
// Definiciones de tipos
//--------------------------------
type Palo  is variant { case Espadas {} case Oros {} case Bastos {} case Copas {} }
type Carta is variant { case Carta   { 
                               field valor 
                               field palo 
                        }
                        case Comodín {}
                      }

//--------------------------------
// Operaciones de palos (interfaz)
//--------------------------------
///*@ATTRIBUTE@tooltip@Denota el palo de una carta de un mazo de cartas españolas*/
///*@ATTRIBUTE@block_name@_@*/
///*@ATTRIBUTE@block_dropdown@[("Espadas", 'Espadas'), ("Oros", 'Oros'), ("Bastos", 'Bastos'), ("Copas", 'Copas')]@*/
//function palo_(palo) { return (palo) }

///*@ATTRIBUTE@tooltip@Denota el palo de espadas de un mazo de cartas españolas*/
/*@ATTRIBUTE@block_name@Espadas@*/function espadas() { return(Espadas) }
/*@ATTRIBUTE@block_name@Oros@*/   function oros()    { return(Oros)    }
/*@ATTRIBUTE@block_name@Bastos@*/ function bastos()  { return(Bastos)  }
/*@ATTRIBUTE@block_name@Copas@*/  function copas()   { return(Copas)   }

/*@ATTRIBUTE@block_name@_ es menor palo que _@*/
function esMenorPalo__(palo1, palo2) { return(aux_esMenorPalo(palo1, palo2)) }

/*@ATTRIBUTE@block_name@palo siguiente a _@*/
function paloSiguiente_(palo) { return(aux_paloSiguiente(palo)) }

/*@ATTRIBUTE@block_name@carta previa a _@*/
function paloPrevio_(palo) { return(aux_paloPrevio(palo)) }

//--------------------------------
// Operaciones de cartas (interfaz)
//--------------------------------
/*@ATTRIBUTE@block_name@carta _ de _@*/   function dameCarta__(v,p) { return(aux_armarCarta(v, p))    }
/*@ATTRIBUTE@block_name@comodín@*/        function dameComodín()    { return(aux_armarComodín())      }
/*@ATTRIBUTE@block_name@es comodín _@*/   function esComodín_(c)    { return(aux_esComodín(c))   }
/*@ATTRIBUTE@block_name@palo de la _@*/   function dameElPalo_(c)   { return(aux_dameElPalo(c))  }
/*@ATTRIBUTE@block_name@número de la _@*/ function dameElValor_(c)  { return(aux_dameElValor(c)) }

/*@ATTRIBUTE@block_name@_ es menor carta que _@*/
function esMenorCarta__(carta1, carta2) { return(aux_esMenorCarta(carta1, carta2)) }

/*@ATTRIBUTE@block_name@carta siguiente a _@*/
function cartaSiguiente_(carta) { return(aux_cartaSiguiente(carta)) }

/*@ATTRIBUTE@block_name@carta previa a _@*/
function cartaPrevia_(carta) { return(aux_cartaPrevia(carta)) }

//--------------------------------
// Operaciones de sensado de cartas (interfaz)
//--------------------------------
function hayCarta()          { return(aux_hayCarta())                 }
function laCartaEstáTapada() { return(aux_laCartaEstáTapadaConBoom()) }
function hayCartaTapada()    { return(aux_hayCarta() && aux_laCartaEstáTapada()) }
// ---
// Específicas para Memotest
// ---
function laCartaEstáIluminada()             { return(aux_laCartaEstáIluminadaConBoom())      }
function hayCartaDestapadaSinIluminar()     { return(aux_hayCartaDestapadaSinIluminar())     }
function hayOtraCartaDestapadaSinIluminar() { return(aux_hayOtraCartaDestapadaSinIluminar()) }

//--------------------------------
// Operaciones de mostrado de cartas (interfaz)
//--------------------------------
function  leerCarta()                        { return(aux_leerCarta())              }

procedure PonerCarta_(carta)                 { AuxPonerCartaDestapada(carta)        }
procedure SacarCarta()                       { AuxSacarCartaActual()                }
procedure DarVueltaLaCartaActual()           { AuxGirarCartaActual()                }
procedure IluminarLaCartaActual()            { AuxIluminarCartaActual()             }

procedure PonerCartaTapada_(carta)           { AuxPonerCartaTapada(carta)           }
procedure PonerCartaDestapada_(carta)        { AuxPonerCartaDestapada(carta)        }
//--------------------------------
//--------------------------------
// FIN INTERFAZ de 03-Cartas-Base.gbs
//--------------------------------
//--------------------------------

//--------------------------------
//--------------------------------
// AUXILIARES de 03-Cartas-Base.gbs
//--------------------------------
//--------------------------------

//--------------------------------
// Auxiliares para construir cartas
//--------------------------------
function aux_armarComodín() { return(Comodín) }
function aux_armarCarta(valor,palo) {
  // PRECONDICIÓN: valor y palo corresponden a los de una carta válida
  if (not (valor >= 1 && valor <= 12)) { BOOM("No existen cartas de ese valor") }
  return(Carta(valor <- valor, palo <- palo)) 
}

function aux_armarCartaParaElCódigo(códigoDelDatoCarta) {
  if (códigoDelDatoCarta == aux_códigoDelComodín()) 
         { valorDeRetorno := aux_comodín() }
    else {
           let (valor, códigoPalo) := aux_analizarDatoCarta(códigoDelDatoCarta)
           valorDeRetorno := aux_armarCarta(valor,aux_paloParaElCódigo(códigoPalo))
         }
  return(valorDeRetorno)
}

//--------------------------------
// Auxiliares para acceso a cartas
//--------------------------------
function aux_esComodín(carta) { return(carta==Comodín) }

function aux_dameElPalo(carta) { 
  // PRECONDICIÓN: la carta no es el comodín
  if (aux_esComodín(carta)) { BOOM("El comodín no tiene palo") }
  return(palo(carta)) 
}

function aux_dameElValor(carta) { 
  // PRECONDICIÓN: la carta no es el comodín
  if (aux_esComodín(carta)) { BOOM("El comodín no tiene valor") }
  return(valor(carta)) 
}

function aux_esMenorCarta(carta1, carta2) {
   if (aux_esComodín(carta1) || aux_esComodín(carta2))
         { respuesta := not aux_esComodín(carta1) }  
         // si la carta1 no es comodín, la carta2 debe serlo, y entonces es menor, y si es, no puede ser menor
    else {
           respuesta := (aux_esMenorPalo(palo(carta1), palo(carta2))) 
                     || (palo(carta1) == palo(carta2) && valor(carta1) < valor(carta2))
         }
   return(respuesta)
}
                                    
function aux_cartaSiguiente(carta) {
   if (aux_esComodín(carta))
         { valorDeRetorno := aux_armarCarta(1, aux_minPalo()) }
    else {
           valor := valor(carta)
           palo  := palo(carta)
           valorDeRetorno := choose
                              aux_armarCarta(1, aux_paloSiguiente(palo)) when (valor == 12 && not (palo == aux_maxPalo()))
                              aux_armarCarta(valor+1,palo)               when (valor <  12)
                              aux_armarComodín()                         otherwise // (valor == 12 && palo == aux_maxPalo())
         }
  return(valorDeRetorno)         
}

function aux_cartaPrevia(carta) {
   if (aux_esComodín(carta))
         { valorDeRetorno := aux_armarCarta(12, aux_maxPalo()) }
    else {
           valor := valor(carta)
           palo  := palo(carta)
           valorDeRetorno := choose
                              aux_armarCarta(1, aux_paloPrevio(palo)) when (valor == 1 && not (palo == aux_minPalo()))
                              aux_armarCarta(valor-1,palo)            when (valor >  1)
                              aux_armarComodín()                      otherwise // (valor == 1 && palo == aux_minPalo())
         }
  return(valorDeRetorno)         
}

//--------------------------------
// Auxiliares para sensar cartas en el tablero
//--------------------------------
function aux_hayCarta() { return (aux_hayTipoCarta() && aux_hayDatoCarta()) }

function aux_laCartaEstáTapada() { 
   // PRECONDICIÓN: hay una carta
   return (aux_hayReverso())
}

function aux_laCartaEstáTapadaConBoom() { 
   if (not aux_hayCarta()) { BOOM("No hay una carta que pueda estar tapada") }
   return(aux_laCartaEstáTapada())    
}

function aux_hayCartaDestapada() { 
   return (aux_hayCarta()           
        && not aux_laCartaEstáTapada())
}

//--------------------------------
// Operaciones de E/S de cartas
//--------------------------------
function aux_leerCarta() {
  // PRECONDICIÓN: hay una carta destapada en la celda actual
  if (not aux_hayCarta())      { BOOM("No hay una carta que pueda leer") }
  if (aux_laCartaEstáTapada()) { BOOM("No puedo leer una carta tapada")  }
  return(aux_armarCartaParaElCódigo(aux_leerDato()))
}         

procedure AuxPonerCartaTapada(carta) {
  // PRECONDICIÓN: no hay una carta en la celda actual
  // El BOOM lo hace AuxPonerCartaDestapada
  // if (aux_hayCarta()) { BOOM("No puedo bajar una carta donde ya hay una") }
  AuxPonerCartaDestapada(carta)
  AuxTaparCartaActual()
}

procedure AuxPonerCartaDestapada(carta) {
  // PRECONDICIÓN: no hay una carta en la celda actual
  if (aux_hayCarta()) { BOOM("No puedo bajar una carta donde ya hay una") }
  AuxSacarTodas()
  AuxPonerRepresentaciónDeCarta(carta)
}

procedure AuxSacarCartaActual() {
  // PRECONDICIÓN: hay una carta destapada en la celda actual
  if (not aux_hayCarta())       { BOOM("No hay una carta que pueda sacar") }
  if (aux_laCartaEstáTapada())  { BOOM("No puedo sacar una carta tapada")  }
  AuxSacarRepresentaciónDeCarta()
}

procedure AuxGirarCartaActual() {
   if (not aux_hayCarta())         { BOOM("No hay una carta que pueda girar")   }
   if (aux_laCartaEstáIluminada()) { BOOM("No puedo girar una carta iluminada") }
   if (aux_laCartaEstáTapada()) 
        { AuxDestaparCartaActual() }
   else { AuxTaparCartaActual()    }
}

procedure AuxTaparCartaActual()    { 
  // PRECONDICIÓN: hay una carta destapada y no iluminada en la celda actual
  AuxPonerAtributoReverso()
}

procedure AuxDestaparCartaActual() { 
  // PRECONDICIÓN: hay una carta tapada en la celda actual
  AuxSacarAtributoReverso()
}

procedure AuxIluminarCartaActual() {
  /* PROPÓSITO:
      - si hay una carta destapada sin iluminar, la ilumina.
	  - en cualquier otro caso, no hace nada 
	     (las cartas tapadas o iluminadas permanecen igual y 
		  si no hay carta, no pasa nada)
  */
   if (aux_hayCartaDestapadaSinIluminar()) { AuxPonerAtributoIluminación() } 
}

//--------------------------------
// Operaciones auxiliares de codificación
//--------------------------------
function aux_códigoParaElTipoCarta()      { return(3)                                                    }
function aux_códigoParaElDatoCarta(carta) { return(aux_códigoParaElPalo(palo(carta))*100 + valor(carta)) }

function aux_hayTipoCarta()      { return (aux_esTipoCarta(aux_leerTipo())) }
function aux_hayDatoCarta()      { return (aux_esDatoCarta(aux_leerDato())) }

function aux_esTipoCarta(código) { return (código == aux_códigoParaElTipoCarta()) }
function aux_esDatoCarta(dato) {
  let (valor, códigoPalo) := aux_analizarDatoCarta(dato)
  return (valor <= 12 && códigoPalo >= 1 && códigoPalo <= 5)
}

function aux_analizarDatoCarta(dato) { return (dato mod 100, dato div 100)       }
 
function aux_códigoParaElAtributoReverso() { return(1) }
function  aux_hayReverso()          { return (nroBolitas(aux_colorParaElAtributo())==aux_códigoParaElAtributoReverso()) }
procedure AuxPonerAtributoReverso() { Poner__Veces(aux_colorParaElAtributo(), aux_códigoParaElAtributoReverso())        }
procedure AuxSacarAtributoReverso() { Sacar__Veces(aux_colorParaElAtributo(), aux_códigoParaElAtributoReverso())        }

function aux_códigoParaElAtributoIluminación() { return(2) }
function  aux_hayIluminación()          { return (nroBolitas(aux_colorParaElAtributo())==aux_códigoParaElAtributoIluminación()) }
procedure AuxPonerAtributoIluminación() { Poner__Veces(aux_colorParaElAtributo(), aux_códigoParaElAtributoIluminación())        }
procedure AuxSacarAtributoIluminación() { Sacar__Veces(aux_colorParaElAtributo(), aux_códigoParaElAtributoIluminación())        }

procedure AuxPonerRepresentaciónDeCarta(carta) {
  // PRECONDICIÓN: la celda está vacía
  AuxPoner__Veces(aux_colorParaElTipo(), aux_códigoParaElTipoCarta()) 
  AuxPoner__Veces(aux_colorParaElDato(), aux_códigoParaElDatoCarta(carta)) 
}

procedure AuxSacarRepresentaciónDeCarta() { 
   // PRECONDICIÓN: hay una representación de cartas
   AuxSacarTodas() 
}

// ---
// ---
// ---
// Específicas para Memotest
// ---
// ---
// ---
function aux_laCartaEstáIluminada() {
   // PRECONDICIÓN: hay una carta y no está tapada
   return (aux_hayIluminación())
}

function aux_laCartaEstáIluminadaConBoom() { 
   if (not aux_hayCarta())      { BOOM("No hay una carta que pueda estar iluminada")    }
   if (aux_laCartaEstáTapada()) { BOOM("Las cartas tapadas no pueden estar iluminadas") }
   return(aux_laCartaEstáIluminada()) 
}

function aux_hayCartaDestapadaSinIluminar() { 
   return (aux_hayCarta()           
        && not aux_laCartaEstáTapada()
		&& not aux_laCartaEstáIluminada())
}

function aux_hayOtraCartaDestapadaSinIluminar() {
  // PRECONDICIÓN: no hay ninguna celda marcada
  AuxMarcar()
  IrAlBorde(Sur) IrAlBorde(Oeste)
  while (not aux_terminoElRecorrido() && not aux_hayCartaDestapadaSinIluminarYSinMarca()) 
     { AuxPasarASiguientePosición() }
  valorDeRetorno := aux_hayCartaDestapadaSinIluminarYSinMarca()
  AuxVolverALaMarca()
  AuxDesmarcar()
  return(valorDeRetorno)
}                                    

function aux_hayCartaDestapadaSinIluminarYSinMarca() { 
    return (aux_hayCartaDestapadaSinIluminar() && not aux_hayMarca()) 
}

//--------------------------------
// Operaciones auxiliares de palos
//--------------------------------
function aux_esMenorPalo(palo1, palo2) {
    return (aux_códigoParaElPalo(palo1) < aux_códigoParaElPalo(palo2))
}

function aux_paloParaElCódigo(código) {
  // PRECONDICIÓN: el código es válido, o sea, corresponde a un palo (está entre 1 y 4)
  switch (código) to {
    1 -> { valorDeRetorno := Bastos  }
    2 -> { valorDeRetorno := Copas   }
    3 -> { valorDeRetorno := Espadas }
    4 -> { valorDeRetorno := Oros    }
    _ -> { BOOM("No es un código de palo válido") }
  }
  return(valorDeRetorno)
}

function aux_códigoParaElPalo(palo) { 
  switch (palo) to {
    Bastos  -> { valorDeRetorno := 1 }
    Copas   -> { valorDeRetorno := 2 }
    Espadas -> { valorDeRetorno := 3 }
    Oros    -> { valorDeRetorno := 4 }
  }
  return(valorDeRetorno)
}

function aux_minPalo() { return (aux_códigoParaElPalo(1)) }
function aux_maxPalo() { return (aux_códigoParaElPalo(4)) }

function aux_paloSiguiente(palo) {
   return (choose 
            aux_minPalo()                                      when (palo == aux_maxPalo())
            aux_paloParaElCódigo(aux_códigoParaElPalo(palo)+1) otherwise
          )
}

function aux_paloPrevio(palo) {
   return (choose 
            aux_maxPalo()                                      when (palo == aux_minPalo())
            aux_paloParaElCódigo(aux_códigoParaElPalo(palo)-1) otherwise
          )
}

//--------------------------------
//--------------------------------
// FIN AUXILIARES de 03-Cartas-Base.gbs
//--------------------------------
//--------------------------------

